# 运输层

## 概述和运输层服务

运输层协议为运行在不同端系统上的应用进程之间提供**逻辑通信**功能

运输层协议是在端系统中实现的而不是在路由器中实现的

### 运输层和网络层的关系

网络层：像邮政的网络，负责从上海到北京的数据传输

运输层：从上海收集数据，并且交给网络层来传输

### 因特网运输层概述

报文段：运输层分组

数据报：UDP的分组

IP

- 网络层
- 尽力而为交付服务
- 不确保报文段的交付，不保证报文段按序交付，不保证报文段中数据完整性

## 多路复用与多路分解

多路分解

- 传输层向同一台主机上的不同Socket传输数据的过程

多路复用

- 传输层从同一台主机上的不同Socket接收数据的过程
- **报文段结构**
  - 源端口号
  - 目的端口号
  - 其他首部字段
  - 应用数据（报文）
- 套接字有唯一标识符，每个报文段有特殊字段来指示该报文段要交付到的套接字
- 端口号0-1023为周知端口号，保留给周知应用层协议

无连接的多路复用与多路分解

- 一个UDP套接字是由一个二元组标识的，该二元组包含一个目的IP地址和目的端口号
- 运输层只识别目标IP、端口号，如果两个报文段IP、端口号相同，将会通过相同的套接字定向到相同的目的进程
- 源端口号作用：作为返回地址

面向连接的多路复用与多路分解

- 一个TCP套接字是由一个四元组标识的，该四元组包含源IP地址，源端口号，目的IP地址和目的端口号
- 两个具有不同IP地址或不同源端口号的报文段将被定向到两个不同的套接字

## 无连接运输：UDP

无连接：在发送报文段之前，发送方和接收方的运输层实体之间没有握手

使用UDP的时候差不多相当于直接在和IP打交道

UDP的优点

- 关于发送什么数据、何时发送的应用层控制更加精细
- 无须建立连接
- 无连接状态（不用在端系统中维护连接状态）
- 分组首部开销小（TCP 20 字节，UDP 8 字节）

UDP也可能实现可靠传输——通过应用程序的相关机制来实现（Google的QUIC协议）

### UDP报文段结构

- 源端口号
- 目的端口号
- 长度——UDP报文段的字节数，因为不同UDP段字节数不同
- 检验和——用来检查在该报文段中是否出现了差错
  - 将报文段中所有16bit字求和，然后将这个和进行反码运算，求和时舍去所有溢出
  - UDP提供检验和的原因是不能保证源和目的地之间所有链路都提供差错检测
  - **端到端原则**：因为某一功能必须在端到端实现，与在较高层次提供这些功能的代价相比，在较低层次上设置的功能可能是冗余的，或者根本是没有用的
- 应用数据（报文）

## 可靠数据传输原理

抽象：数据通过一条可靠的信道进行传输

实现：可靠数据传输协议(reliable data transfer protocol)

### rdt1.0

提一下这里的有限状态机（FSM）：虽然看着很唬人，但是实际上就是把所有的状态、情况枚举出来

假设：底层信道完全可靠，接收方接受数据的速率能够和发送方一样快

实现：接收端不需要提供任何反馈信息给发送方，因为不会出现差错

### rdt2.0

假设：分组中的bit可能受损，不会丢包

解决办法：在这样的假设下，接收方需要确认是否收到信息，发送方需要知道哪些信息被正确接收，并把没有被接收的数据重传

基于这样重传机制的rdtp：自动重传请求（Automatic Repeat reQuest，ARQ）协议

- 差错检测
  - 检验和字段
- 接收方反馈
  - 如果出现问题，就发送否定确认（NAK），如果没有问题，就发送肯定确认（ACK）
- 重传
  - 接收方收到有差错的分组，发送方将会重传分组

这一版本的协议被称为**停等**协议：除非发送方确认接收方已经正确接收当前分组，否则不会发送新数据（stop-and-wait）

### rdt2.1

假设：和rdt2.0一样

rdt2.0存在一个问题：如果ACK、NAK受损，怎么处理？

核心问题：虽然可以检测出受损，但是无法恢复受损ACK或NAK的值

解决办法：

- 发送方收到一个模糊不清的ACK或NAK分组时，重发响应报文

- 同时，发送方对其数据分组编号，这样接收方可以知道收到的分组是否是一次重传还是一个新分组，如果已经接收到重传的报文，就将其丢弃
- 对于停等协议的情况，1比特的序号就足够了

### rdt2.2

假设：和rdt2.0一样

改进：

- 如果收到受损分组之后，接收方不发送NAK，而是对上次接收正确的分组发送一个ACK，这样，发送方收到对同一个分组的两个ACK（冗余ACK），借知道接收方没有正确接收在被确认两次的分组之后的分组

- 这样实现了一个无NAK的rdt

解决方法：

- 接收方发送的ACK分组必须包含一个分组序号

### rdt3.0

假设：分组中的bit可能受损，会丢包

问题：怎样检测丢包？丢包后如何处理？

解决：

- 设定一个倒计数定时器，在一个给定的时间量之后，重传数据
- 可能引入冗余数据分组，但是rdt2.2已经可以通过序号来解决

### 流水线可靠数据传输协议

rdt3.0性能上的问题：

- 它是一个停等协议
- 需要等待接收方返回信息之后才能进行下一步发送
- 信道的利用率很低

解决方法：

- 允许发送方发送多个分组而无须等待确认
- 分组可以被看成是填充到一条流水线中，因此这种技术被称为**流水线**
- 流水线
  - 必须增加序号范围
  - 协议的接收方、发送方需要缓存多个分组
  - 序号范围、缓冲要求取决于如何解决丢失
    - 回退N步（Go-Back-N, GBN）
    - 选择重传（Selective Repeat, SR）

回退N步

- 流水线中未确认的分组数不能超过某个最大允许数N
- 那些已被发送但还未被确认的分组的许可序号范围可以被看成是在一个序号长度为N的窗口
- N被称为窗口长度，GBN协议也被称为**滑动窗口协议**
- 发送方收到一个序号为n的分组的ACK表明接收方已经接收到序号为n及以前的所有分组
- 接收方丢失所有失序的分组——接收缓存简单
- 发送方重传——三个重复ACK或者某个包超时

选择重传

- SR接收方将确认一个正确的分组而不管其是否按序
- 失序的分组将被缓存直到所有丢失分组（序号更小的分组）都被收到
- 如果到一个范围n内的分组都被正确收到，在此情况下，必须产生一个ACK，告知发送方n及以前的所有分组都已经被收到
- 如果没有这个ACK，发送方窗口将无法向前滑动
- 窗口长度必须小于等于序号空间大小的一半（如果窗口长度大于序号空间长度，接收方无法分辨是一个新分组还是一次重传
- 避免分组重新排序产生的相同序号的旧副本——设定最长分组寿命，超过这一寿命之后才使用这一序号

## 面向连接的运输：TCP

### TCP连接

TCP是面向连接的，在一个进程向另一个进程发送数据前，两个进程之间必须先相互握手

三次“**招手**”（实际上就是一次握手，因为所谓握手，你两边分别伸手，就叫两次握手？）

- 客户先发送一个特殊的TCP报文段作为响应
- 服务器用另一个特殊的TCP报文段来响应
- 最后，客户再用第三个特殊TCP报文段来响应
- 前两个报文段不承载有效载荷，而第三个报文段可以承载有效载荷

TCP将穿过套接字的数据引导到该连接的发送缓存中

TCP从缓存放入报文段的数据数量受限于**最大报文长度**（Maximum Segment Size, MSS），MSS是整个应用层TCP报文段的最大长度

MSS的值通常有最大传输单元（Maximum Transmission Unit, MTU）来设置，MTU受链路层的最小值限制

### TCP报文段

- 源端口号
- 目的端口号
- 序号
  - 该报文段首字节的字节流编号
- 确认号
  - 希望从对方收到的下一个数据段的编号
  - 累计确认：TCP值确认该流中至第一个丢失字节为止的字节
  - TCP会保留失序字节
  - TCP双方会随机选择初始序号
- 首部长度
  - 因为选项字段的存在，首部长度是可变的
- 保留未用
- 标志字段
  - ACK——确认有效
  - RST、SYN、FIN——建立连接和拆除
  - CWR、ECE——明确拥塞
  - PSH、URG——实际没用
- 接收窗口
  - 用于流量控制，表示接收方愿意接收的字节数量
- 因特网检验和
- 紧急数据指针
  - 实际没用
- 选项
  - 用于协商MSS
- 数据

捎带：将返回的数据放进ACK之中

### 往返时间的估计与超时

TCP使用一种样本RTT（Sample RTT）的方法来估计RTT

**Sample RTT**就是从某报文段发出到收到对该报文段的确认之间的时间量

TCP并不为已经重发的报文段做Sample RTT测试，它只为传输一次的报文段测量Sample RTT

#### 指数加权移动平均

>  **Estimated_RTT = (1 - a) * Estimated_RTT+ a * Sample_RTT**

a一般取1/8

因为Estimated RTT表示最近的网络状况，所以其理应得到较大的权值这种方法也被称为

> **Dev_RTT = (1 - b) * Dev_RTT + b * (Sample_RTT - Estimated_RTT)**

Dev_RTT表示Sample_RTT的变化率

TCP采取的往返时间的估计公式：

> **Timeout_Interval = Estimated_RTT + 4 * Dev_RTT**

如果出现超时之后，Timeout_Interval将加倍

不管怎么样，一旦报文段收到并更新Estimated_RTT后，Timeout_Interval就又用该公式计算

### 可靠数据传输

由于管理定时器的开销很大，TCP协议仅使用单一的重传定时器

- TCP发送一个报文段，并启动定时器
  - TCP接到ACK信号，表明y已经ok——把窗口移动到ok的位置，如果此时还有未被确认的报文段，则重新启动定时器
  - 定时器超时——重传具有最小序号但仍未应答的报文段，重新启动定时器

- 超时之后，Timeout_Interval每次加倍
- 快速重传——接收到三个冗余ACK，那么说明这个报文段已经丢失，TCP执行快速重传
- **TCP的一种修改意见：TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段**
- TCP的差错恢复机制可以被看作是GBN与SR的混合体




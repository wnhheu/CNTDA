# 第二章 应用层

<!--more-->

## 应用层协议原理

研发网络应用的核心是写出能够运行在不同端系统和通过网络彼此通信的程序，与此同时，我们不需要写在网络核心设备如路由器或者链路层交换机上运行的软件

### 网络应用程序体系结构

- 客户-服务器体系结构
  - 有一个总是打开的主机（服务器），它服务于来自许多其他称为客户的主机的请求
  - 客户之间不直接通信
  - 服务器具有固定的、周知的地址(IP地址)
- P2P体系结构
  - 对位于数据中心的专用服务器有最小的（或者没有）一来
  - 应用程序在间断连接的主机对之间使用直接通信，这些主机被称为对等方
  - 具有自扩展性——在文件共享应用中，对等方可能通过向文件的原始拥有者发出请求而产生工作量，但是对等方也有可能通过为其他对等方传送文件而为原始拥有者增加服务能力

### 进程通信

进程：运行在端系统中的一个程序
在两个不同端系统上的进程，通过跨越计算机网络交换报文而互相通信
客户：在会话中发起通信的进程
服务器：在会话开始时等待联系的进程
进程通过一个称为**套接字**的软件接口向网络发送或者从网络接收报文
进程寻址

- 需要主机的地址（IP地址）
- 在目的主机中指定接收进程的标识符（端口号）
- 已经给流行的应用分配了特定的端口号

### 可供应用程序使用的运输服务

- 可靠数据传输
  - 确保数据不会丢失
- 吞吐量
  - 以某种特定的速率提供确保的可用吞吐量
  - 弹性应用：根据可用带宽的多少利用可供使用的吞吐量
- 定时：
  - 保证用时上限
- 安全性
  - 加密传输的数据

### 因特网提供的运输服务

- TCP
  - 面向连接
  - 可靠的数据传输
  - 拥塞控制机制
  - 可以通过在应用层引入SSL来实现加密
- UDP
  - 只提供最小服务
  - 不包括拥塞控制机制

因特网不提供定时传输服务

### 应用层协议

- 交换的报文类型，请求报文和响应报文
- 各种报文类型的语法
- 字段的语义（这些字段中的信息的含义）
- 确定要给进程何时、如何发送报文，对报文进行响应的规则

## Web 和 HTTP

### HTTP概况

HTTP：超文本传输协议
Web页面是由对象组成的
对象：一个文件，可通过URL地址寻址
URL：统一地址定位符，是互联网上标准资源的地址，由两部分组成：存放对象的路径名和对象的路径名
Web浏览器实现了HTTP的客户端，Web服务器实现了HTTP的服务端
HTTP是**无状态协议**——HTTP服务器不保存客户的任何信息
HTTP使用TCP作为它的传输层协议，故而HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节

### 非持续连接和持续连接

RTT：一个短分组从客户到服务器然后再返回客户所花费的时间
非持续连接：每个请求/响应对是经一个单独的TCP连接发送
- 非持续连接在建立TCP连接的过程中涉及到“三次握手”，占用一个RTT，HTTP请求/响应用去了另一个RTT总响应时间是两个RTT加上服务器传输HTML文件的时间
- 对于每一个连接，服务器和客户都要分配TCP缓冲区、保持TCP变量，给Web服务器带来了严重的负担
持续链接：所有的请求及其响应经相同的TCP连接发送
- 服务器在发送响应后保持TCP连接打开
- 对对象的请求可以一个接一个地发出，而不必等待对未决请求的回答（像流水线一样）
- 如果一条连接经过一定时间间隔仍未被使用，HTTP服务器就关闭该连接
HTTP默认使用的是带流水线的持续连接

### HTTP报文格式

#### 请求报文

- 请求行
  - 第一行
  - 包含方法字段、URL字段、HTTP版本字段
    - 方法字段：GET, POST, HEAD, PUT, DELETE
- 首部行
  - 请求行后的行
  - HOST：指明对象所在的主机
  - Connection：告诉服务器是否需要使用持续连接
  - User-agent：向服务器发送请求的浏览器类型（服务器可以为不同浏览器发送内容的不同版本，这些版本的URL相同）
  - Accept-language：希望得到的版本语言
- 首部行后有实体体（只在方法字段为POST时有内容），其内容依赖于用户在表单字段输入的内容
- 同时，HTML表单经常使用GET方法来生成请求报文（不是必须使用POST）

#### 响应报文

- 状态行
  - 第一行
  - 协议版本字段、状态码、相应状态信息
- 首部行
  - Connection：close——完成发送后将关闭TCP连接
  - Date：从文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间
  - Last-Modified：对象最后修改的日期、时间（用于缓存服务器）
- 实体体

### Cookie

Web站点通过cookie来识别用户
cookie技术有四个part
- HTTP响应报文中的cookie首部行（第一次访问时发送）
- HTTP请求报文中的cookie首部行（后面每一次访问时发送给服务器，这个值又服务器在前面发送给客户端）
- 用户端系统中的cookie文件，由浏览器保存维护
- Web站点的一个后端数据库，建立Cookie和用户身份的关联

### Web缓存（代理服务器）

- 当代理服务器收到一个HTTP请求后，它将检查本地是否缓存过该对象，
- 如果缓存过该对象，将检查是否过期
- 如果没有过期，则直接将该对象返回给浏览器
- 如果本地不存在或者存在已过期，则代理服务器将根据请求报文里的Host首部行以及请求行里的URL字段向初始服务器发出请求，然后将响应对象返回给浏览器并缓存在本地
采用条件GET方法——在请求报文中加入If-Modified-Since

##  因特网中的电子邮件

**用户代理**、**邮件服务器**、**SMTP**

邮件发送流程：A的用户代理->A的邮件服务器->B的邮件服务器->B的用户代理
如果A的邮件服务器在一个报文队列中保持该报文，并在以后尝试送达

### SMTP

- **传输的三个阶段**：握手、传输、关闭连接
- SMTP25号端口。SMTP是**持续连接**的。对每一报文，客户使用一个新的MAIL FROM：crepes.fr开始。当所有报文发送完后才发送QUIT，断开连接
- SMTP报文一般不**使用中间邮件服务器发送报文**，也就是邮件不会在中间某个邮件服务器保留；在SMTP握手阶段，SMTP客户端将介绍发送方和接收方的邮箱地址；一旦介绍完毕后，SMTP客户端将开始发送报文
- **SMTP是邮件服务器之间发送邮件报文**

- 与HTTP对比：
  - HTTP被设计为一个Pull协议而SMTP被设计为一个Push协议。即用户通过HTTP主动向服务器请求内容，而SMTP则是客户将内容推向服务器端
  - HTTP传输的数据不一定是用ASCII字符，但是SMTP则只能使用ASCII字符
  - HTTP将每个对象封装在自己的响应报文里，而SMTP则将所有的报文对象放到一个报文之中

- 邮件报文格式
  - 首部行（From，To，Subject）
  - 报文体

###　邮件访问协议

用户代理使用邮件访问协议来从邮件服务器上获取邮件信息

- POP3（建议看书）
- IMAP（建议看书）（因为感觉邮件这块不是很重要，~~主要是我懒且这块也没有太读懂~~
- 基于Web的电子邮件
  - 用户和远程邮箱之间的通信通过HTTP进行

## DNS：因特网的目录服务

### DNS提供的服务

- 主机名到IP地址的转换
- 主机别名（有着复杂主机名的主机能拥有一个或多个别名） **规范主机名**（书上没有详细讲）
- 邮件服务器别名
- 负载分配
  - 每个服务器有着不同的IP地址，但是它们都和同一个主机名相关联，也就是一个IP地址集合同一个规范主机名相联系
  - 当某个DNS服务器收到DNS请求时，该服务器奖使用IP地址的整个集合作为响应，但是在每个应答中，循环这些地址的次序
  - 因为客户端通常都是使用IP地址集合的首个元素，所以DNS就在冗余的Web服务器之间分配了负载。同理，多个邮件服务器可以具有相同的别名

### DNS工作机理概述

#### 分布式、层次数据库

- 根DNS服务器
  - 提供了TLD服务器的IP地址
- 顶级域（Top-Level Domain）DNS服务器（com、org、cn、jp，etc）
  - 提供了权威DNS服务器的IP地址
- 权威DNS服务器
  - 收藏了因特网上可以公共访问主机的组织机构（学习、公司）提供的公共课访问的DNS记录
- 还有一类服务器：本地DNS服务器
	- 当主机与ISP连接时，会连到这个ISP的本地DNS服务器（代理服务器）

查询方式：递归/迭代

- 递归是指A->B->C->D(D是target)
- 迭代是指A->B,B返回C的地址给A，A->C，C返回D的地址给A，A->D
- 这里的B、C、D都是DNS服务器

#### DNS缓存

每当DNS服务器发出请求后收到回答时，就将回答的内容缓存在它自己的主机空间上
DNS服务器在经过一段时间后，会丢弃缓存的信息（时效性）
改善时延性能并且减少因特网上传输的DNS报文数量

### DNS记录和报文

共同实现分布式数据库的所有DNS服务器存储了资源记录RR(Resource Record)，提供了主机名到IP地址的映射信息；

#### RR

- 具有以下字段的4元组：｛name, value, type, TTL｝（其中TTL是指该记录的生存时间，它决定了该条记录何时被删除）
- type
  - type=A：name为主机名，value为对应的IP地址
  - type=NS：name为域，value为如何获得该域下主机IP地址的权威DNS服务器的主机名
  - type=CNAME：value为name（本身为主机别名）所对应的主机的规范主机名
  - type=MX：value为那么所对应的邮件服务器的规范主机名；

#### DNS报文

- 首部区域
  - 前12字节
  - 标识符是一个用来标记该查询的16比特数，该标识符会被复制到相应的回答报文里，以便匹配请求和回答
  -  标志字段有若干标志，用来指出报文的类型（请求还是响应）、查询类型（递归还是迭代）、是否是所请求名字的权威DNS服务器、以及4个有关数量的字段，用来指示4类数据区域出现的数量
- 问题区域
  - 包含了正在进行的查询信息，包括名字字段、查询类型
-  权威区域
  - 包含了其他权威服务器的信息
-  附加区域
  - 包含了其它有帮助的记录
  - 比如在对于一个MX类型的请求回答报文里，回答区域里指出了邮件服务器的规范主机名，而附加区域里就有可能包含一个类型为A的关于该规范主机名的的IP地址

#### 向DNS数据库中插入数据

需要在注册登记机构完成这一任务，当你注册一个域名时，需要向该机构提供你的基本和辅助DNS服务器的名字和IP地址
该注册机构将确保一个类型为NS和类型为A的记录输入对应的顶级域名服务器

### P2P文件分发(BitTorrent)

BitTorrent ——一种用于文件分发的流行P2P协议

洪流：

- 参与一个特定文件分发的所有对等方的集合

- 在一个洪流中的对等方彼此下载等长度的文件块；当一个对等方下载文件块的时候，也向其他对等方发送了多个块

- 一旦某对等方获得了完整文件，就可以自私地离开洪流或者大公无私地留下来继续向其他对等方发送文件

### 视频流和内容分发网

#### 因特网视频

视频——高比特率，可以被压缩

对流式视频（视频数据的传输）最重要的性能度量是平均端到端吞吐量

可以用压缩生成相同视频的多个版本，每个版本有不同的质量等级，用户可以根据当前的带宽来决定观看哪个版本

#### HTTP流和DASH

HTTP流

- 视频存储在服务器中作为一个普通的文件
- 在用户一侧，字节被收集在客户应用的缓存中，当缓存的字节数超过预先设定的门槛，客户应用程序就开始播放
- 客户接收到相同编码的视频，尽管对不同的客户或者相同客户的不同时间，客户的可用带宽大小不同

DASH

- Dynamic Adaptive Streaming over HTTP
- 用户动态地请求来自不同版本且长度为几秒的视频段数据块
- HTTP服务器也有一个告示文件，为每个版本提供了一个URL及其比特率

#### 内容分发网

CDN(Content Distribution Network)

- CDN管理分布在多个地理位置的服务器，在它的服务器中储存相关文件的副本，并试图将每个用户定向到一个提供最好用户体验的CDN位置
- 专用CDN：由内容提供商自己所拥有
- 第三方CDN：代表多个内容提供商分发内容

两种不同的服务器安置原则

- 深入——在遍及全球的接入ISP中建设服务器集群来深入到ISP的接入网中
  - 高度分布式设计，维护、管理集群较为困难
- 邀请做客——在因特网交换点建造大集群，邀请ISP做客
  - 较低的维护和管理开销，较高的时延和较低的吞吐量

当用户主机中的一个浏览器检索一个特定的视频时，CDN会截获该请求，来确定此时适用于该客户的CDN服务器集群，并将客户的请求重定向到该集群的某台服务器

集群选择策略

- 地理上最为临近
  - 但是就网络路径的长度而言，可能不是最近的
  - 忽视了时延、带宽随时间的变化
- 通过对集群与客户之间的时延、丢包率进行周期性的实时测量，为客户选择最好的集群
  - 实现：CDN让它的每个集群周期性地像位于全世界的LDNS发送探测分组
  - 缺点：许多LDNS被配置为不会响应这些探测  

#### Netflix

有一个运行在亚马逊云的主机上的Web网站来处理若干功能：

- 内容摄取：Netflix接受制片厂电影的母带，并将其上载到亚马逊云的主机上
- 内容处理：为每部电影生成不同的格式，以便于从不同设备访问，并支持DASH
- 向其CDN上载版本：一旦某电影的所有版本均已生成，亚马逊云的主机就向CDN上载这些版本

IXP： 包含整个Netflix流式视频库

本地IXP：包含最为流行的视频

Netflix不使用拉高速缓存，而是在非高峰时段将视频分发给它的CDN服务器，对于不能保存整个库的位置，Netflix只推送最流行的视频

#### YouTube

- 使用拉高速缓存
- 大部分时间，将用户定向到某个集群，使客户与集群间RTT最低；有时为了平衡集群的负载，将客户定向（经DNS）到一个更远的集群

- 没有使用DASH，要求用户人工选择一个版本

### 套接字编程

这一部分等回学校了可能才可以继续，因为笔记本性能实在不是很行。。